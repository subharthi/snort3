#ifndef __ENHANCED_SET_HPP__
#define __ENHANCED_SET_HPP__

// TODO go through the headers and determine which are still necessary
#include <boost/accumulators/accumulators.hpp>
#include <boost/serialization/serialization.hpp>
#include <boost/serialization/nvp.hpp>

using namespace boost::accumulators;

namespace boost {
namespace accumulators {

// TODO when a accumulator is dropped maybe it shouldn't be merged either

////////////////////////////////////////////////////////////////////////////////
// struct enhanced_set
// An enhanced set is an accumulator_set that has been enhanced with extra
// functionality that allows for serialization and merging of accumulator_sets
//
template<typename Sample, typename Features, typename Weight>
struct enhanced_set : detail::accumulator_set_base {
    typedef Sample sample_type;     ///< The type of the samples that will be accumulated
    typedef Features features_type; ///< An MPL sequence of the features that should be accumulated.
    typedef Weight weight_type;     ///< The type of the weight parameter. Must be a scalar. Defaults to void.

    /// INTERNAL ONLY
    ///
    typedef
        typename detail::make_accumulator_tuple<
            Features
          , Sample
          , Weight
        >::type
    accumulators_mpl_vector;

    // generate a fusion::list of accumulators
    /// INTERNAL ONLY
    ///
    typedef
        typename detail::meta::make_acc_list<
            accumulators_mpl_vector
        >::type
    accumulators_type;

    /// INTERNAL ONLY
    ///
    //BOOST_MPL_ASSERT((mpl::is_sequence<accumulators_type>));

    ///////////////////////////////////////////////////////////////////////////////
    /// default-construct all contained accumulators
    enhanced_set()
      : accumulators(
            detail::make_acc_list(
                accumulators_mpl_vector()
              , detail::accumulator_params()(*this)
            )
        )
    {
        // Add-ref the Features that the user has specified
        this->template visit_if<detail::contains_feature_of_<Features> >(
            detail::make_add_ref_visitor(detail::accumulator_params()(*this))
        );
    }

    /// \overload
    ///
    /// \param a1 Optional named parameter to be passed to all the accumulators
    template<typename A1>
    explicit enhanced_set(A1 const &a1)
      : accumulators(
            detail::make_acc_list(
                accumulators_mpl_vector()
              , detail::accumulator_params()(*this, a1)
            )
        )
    {
        // Add-ref the Features that the user has specified
        this->template visit_if<detail::contains_feature_of_<Features> >(
            detail::make_add_ref_visitor(detail::accumulator_params()(*this))
        );
    }

    // ... other overloads generated by Boost.Preprocessor:

    /// INTERNAL ONLY
    ///
#define BOOST_ACCUMULATORS_ACCUMULATOR_GROUP_CTOR(z, n, _)                                \
    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \
    enhanced_set(BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, A, const &a))                   \
      : accumulators(                                                                   \
            detail::make_acc_list(                                                      \
                accumulators_mpl_vector()                                               \
              , detail::accumulator_params()(                                           \
                    *this BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a)                      \
                )                                                                       \
            )                                                                           \
        )                                                                               \
    {                                                                                   \
        /* Add-ref the Features that the user has specified */                          \
        this->template visit_if<detail::contains_feature_of_<Features> >(               \
            detail::make_add_ref_visitor(detail::accumulator_params()(*this))           \
        );                                                                              \
    }

    /// INTERNAL ONLY
    ///
    BOOST_PP_REPEAT_FROM_TO(
        2
      , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)
      , BOOST_ACCUMULATORS_ACCUMULATOR_GROUP_CTOR
      , _
    )

    #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED
    /// \overload
    ///
    template<typename A1, typename A2, ...>
    enhanced_set(A1 const &a1, A2 const &a2, ...);
    #endif

    // ... other overloads generated by Boost.Preprocessor below ...

    ///////////////////////////////////////////////////////////////////////////////
    /// Visitation
    /// \param func UnaryFunction which is invoked with each accumulator in turn.
    template<typename UnaryFunction>
    void visit(UnaryFunction const &func)
    {
        fusion::for_each(this->accumulators, func);
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// Conditional visitation
    /// \param func UnaryFunction which is invoked with each accumulator in turn,
    ///     provided the accumulator satisfies the MPL predicate FilterPred.
    template<typename FilterPred, typename UnaryFunction>
    void visit_if(UnaryFunction const &func)
    {
        fusion::filter_view<accumulators_type, FilterPred> filtered_accs(this->accumulators);
        fusion::for_each(filtered_accs, func);
    }
    
    ///////////////////////////////////////////////////////////////////////////////
    /// The return type of the operator() overloads is void.
    typedef void result_type;

    ///////////////////////////////////////////////////////////////////////////////
    /// Accumulation
    /// \param a1 Optional named parameter to be passed to all the accumulators
    void operator ()()
    {
        this->visit(
            detail::make_accumulator_visitor(
                detail::accumulator_params()(*this)
            )
        );
    }

    template<typename A1>
    void operator ()(A1 const &a1)
    {
        this->visit(
            detail::make_accumulator_visitor(
                detail::accumulator_params()(*this, a1)
            )
        );
    }

    // ... other overloads generated by Boost.Preprocessor:

    /// INTERNAL ONLY
    ///
#define BOOST_ACCUMULATORS_ACCUMULATOR_GROUP_FUN_OP(z, n, _)                              \
    template<BOOST_PP_ENUM_PARAMS_Z(z, n, typename A)>                                  \
    void operator ()(BOOST_PP_ENUM_BINARY_PARAMS_Z(z, n, A, const &a))                  \
    {                                                                                   \
        this->visit(                                                                    \
            detail::make_accumulator_visitor(                                           \
                detail::accumulator_params()(                                           \
                    *this BOOST_PP_ENUM_TRAILING_PARAMS_Z(z, n, a)                      \
                )                                                                       \
            )                                                                           \
        );                                                                              \
    }

    /// INTERNAL ONLY
    ///
    BOOST_PP_REPEAT_FROM_TO(
        2
      , BOOST_PP_INC(BOOST_ACCUMULATORS_MAX_ARGS)
      , BOOST_ACCUMULATORS_ACCUMULATOR_GROUP_FUN_OP
      , _
    )

    #ifdef BOOST_ACCUMULATORS_DOXYGEN_INVOKED
    /// \overload
    ///
    template<typename A1, typename A2, ...>
    void operator ()(A1 const &a1, A2 const &a2, ...);
    #endif

    ///////////////////////////////////////////////////////////////////////////////
    /// Extraction
    template<typename Feature>
    struct apply
      : fusion::result_of::value_of<
            typename fusion::result_of::find_if<
                accumulators_type
              , detail::matches_feature<Feature>
            >::type
        >
    {
    };

    ///////////////////////////////////////////////////////////////////////////////
    /// Extraction
    template<typename Feature>
    typename apply<Feature>::type &extract()
    {
        return *fusion::find_if<detail::matches_feature<Feature> >(this->accumulators);
    }

    /// \overload
    template<typename Feature>
    typename apply<Feature>::type const &extract() const
    {
        return *fusion::find_if<detail::matches_feature<Feature> >(this->accumulators);
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// Drop
    template<typename Feature>
    void drop()
    {
        // You can only drop the features that you have specified explicitly
        typedef typename apply<Feature>::type the_accumulator;
        BOOST_MPL_ASSERT((detail::contains_feature_of<Features, the_accumulator>));

        typedef
            typename feature_of<typename as_feature<Feature>::type>::type
        the_feature;

        (*fusion::find_if<detail::matches_feature<Feature> >(this->accumulators))
            .drop(detail::accumulator_params()(*this));

        // Also drop accumulators that this feature depends on
        typedef typename the_feature::dependencies dependencies;
        this->template visit_if<detail::contains_feature_of_<dependencies> >(
            detail::make_drop_visitor(detail::accumulator_params()(*this))
        );
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// Serialization
    template<typename Args, typename Archive>
    struct serializer_visitor {
        serializer_visitor(Args const &args, Archive &ar, const unsigned int version) : args_(args), ar_(ar), version_(version) {}

        template <typename Accumulator>
        void operator()(Accumulator &acc) const {
            ar_ & boost::serialization::make_nvp(Accumulator::feature_tag::name().c_str(), acc);
        }

    private:
        Args const &args_;
        Archive &ar_;
        unsigned int version_;
    };

    template<typename Args, typename Archive>
    serializer_visitor<Args, Archive> make_serializer_visitor(Args const &args, Archive &ar, const unsigned int version) {
        return serializer_visitor<Args, Archive>(args, ar, version);
    }


    template<class Archive>
    void serialize(Archive &ar, const unsigned int version) {
        visit_if<is_serializable>(
                make_serializer_visitor(
                    detail::accumulator_params()(*this), ar, version));
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// Merging
    template<typename Args>
    struct enhanced_set_visitor {
        enhanced_set_visitor(Args const &args) : args_(args) {}
        
        // If the type is mergable then this function should be used
        template <typename T>
        void add(T &left, T const &right, const boost::mpl::true_ &dummy) const {
            left += right;
        }

        // If the type is not mergable then this function should be used
        template <typename T>
        void add(T &left, T const &right, const boost::mpl::false_ &dummy) const {}

        template <typename T>
        void operator()(T &t) const {
            fusion::filter_view<accumulators_type, is_mergable> mergable_accs(args_[accumulator].accumulators);
            auto &other = fusion::find<T>(mergable_accs);
            if(other != end(mergable_accs)) {
                add( deref(other), t, typename is_base_of<mergable_base, T>::type());
            }
        }


    private:
        Args const &args_;
    };

    template<typename Args>
    enhanced_set_visitor<Args> make_enhanced_set_visitor(Args const &args) {
        return enhanced_set_visitor<Args>(args);
    }

    template <typename Set>
    void operator+=(Set &set) {
        set.visit_if<is_mergable>(make_enhanced_set_visitor(detail::accumulator_params()(*this)));
    }

    ///////////////////////////////////////////////////////////////////////////////
    /// Extracting
    template<typename Args>
    struct extractor_visitor {
        extractor_visitor(Args const &args, std::ostream &out_) : args_(args), out(out_) { }

        template<typename Accumulator>
        void operator()(Accumulator &acc) const {
            std::cout << Accumulator::feature_tag::name() << " : " << acc.result(args_) << std::endl;
        }

    private:
        Args const &args_;
        std::ostream &out;
    };

    template<typename Args>
    extractor_visitor<Args> make_extractor_visitor(Args const &args) {
        return extractor_visitor<Args>(args);
    }

    std::ostream& print(std::ostream& out) { 
        visit(make_extractor_visitor(detail::accumulator_params()(*this), out));
    }
protected:
    accumulators_type accumulators;
}; /* struct enhanced_set */

} /* namespace accumulators */
} /* namespace boost */
#endif // __ENHANCED_SET_HPP__
