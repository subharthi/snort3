--[[
# Copyright 2001-2014 Cisco Systems, Inc. and/or its affiliates. All rights
# reserved.
#
# This file contains proprietary Detector Content created by Cisco Systems,
# Inc. or its affiliates ("Cisco") and is distributed under the GNU General
# Public License, v2 (the "GPL").  This file may also include Detector Content
# contributed by third parties. Third party contributors are identified in the
# "authors" file.  The Detector Content created by Cisco is owned by, and
# remains the property of, Cisco.  Detector Content from third party
# contributors is owned by, and remains the property of, such third parties and
# is distributed under the GPL.  The term "Detector Content" means specifically
# formulated patterns and logic to identify applications based on network
# traffic characteristics, comprised of instructions in source code or object
# code form (including the structure, sequence, organization, and syntax
# thereof), and all documentation related thereto that have been officially
# approved by Cisco.  Modifications are considered part of the Detector
# Content.
#
# Author: Saman Taghavi Zargar <staghavi@cisco.com> 
#
#
#
# Detect hosts that are doing password guessing attacks and/or password
# bruteforcing over SSH.
#
--]]


-- import the types
require "types"
require "service_configurations"
local ipv4 = types.key_value_type.ipv4
local feature = types.metric
local mapper = service_configurations

basetime = os.time()

-- The number of failed SSH connections before an attempter is detected as a password guesser.

local password_guess_threshold = 30

-- The amopunt of time to keep the number of unsuccessful login attempts in order to build
-- a model for the password guessers.

-- address_scan_interval is 30 minutes 1800
local bruteforce_modeling_timeout = 10

-- Exclusion of certain subnets from being tracked as guessers.

--local exclusion_list = {192.168.0.0/24}

----- configure package parameters -------
DetectorPackageInfo = {
    name =  'ssh-bruteforce-detector',
    init =  'init',
    observation_list_names = { 'ssh_password_guesser_observer' },
    timed_callbacks = { {name = 'threshold_function', duration = bruteforce_modeling_timeout},
                        {name = 'export_function', duration = bruteforce_modeling_timeout} }

}

-- configure observation events ------------

ssh_password_guesser_observer  = {
    name = 'ssh-bruteforce-observation',
    --event_filter_rule_header = "tcp $EXTERNAL_NET any -> $HOME_NET 22",
    event_filter_rule_header = "tcp $EXTERNAL_NET any -> 10.10.106.2 22",

    event_filter_rule_options = "",
    event_filter_rule_global_sid = "sid:19559; rev:5",

    statistics_list = {
          -- list of statistcs for this observation
         { name = 'ssh.login.failure',
           key = {ipv4.client_ip},
           value = {ipv4.server_ip},
           -- could sample 5 "uniquely distributed random samples from the observation stream."
           features = {feature.COUNT, feature.SUM},
           key_transforms = { {ipv4.client_ip, mapper.id_map, "client_usr"},
                              {ipv4.server_ip, mapper.geo_map, "server_location"} }
        }
    }
}

------ initialize some state variables here ------
function init(detector_ref)

   -- containers for collecting the observation statistics
     item_ssh_bruteforce_observer = Item:new(detector_ref, 'ssh-bruteforce-observation', 'ssh.login.failure')
end

function threshold_function(detector_ref)
   print ("Threshold function called");
   local curMeasurements = { }
   local curTime = item_ssh_bruteforce_observer:get_st()- basetime
   curMeasurements = item_ssh_bruteforce_observer:range_query(types.metric.SUM)

--   for i in curMeasurements do
--     if (curMeasurements > password_guess_threshold) then
        --print ("%s appears to be gussing SSH passwords.", ipv4.client_ip);
        item_ssh_bruteforce_observer:print_like_json()
--     end
--   end
   item_ssh_bruteforce_observer:range_query(types.metric.COUNT)
   item_ssh_bruteforce_observer:print_like_json()


end

function export_function(detector_ref)
        --print("export_function called")
end

